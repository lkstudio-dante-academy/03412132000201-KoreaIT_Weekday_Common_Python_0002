import os
import sys

import threading
from Example.Example_17.CCounter import CCounter

"""
쓰레드 (Thread) 란?
- CPU 의 작업 시간을 할당 받는 기본 단위를 의미한다. (+ 즉, 프로그램이 실행 되면
메인 쓰레드가 기본적으로 할당 된다는 것을 알 수 있다.)

프로그램이 실행 되면 CPU 의 작업 시간을 할당 받기 위한 쓰레드가 생성 되며 이를 메인 쓰레드라고 한다. (+ 즉,
쓰레드가 존재하기 때문에 CPU 에 의해서 명령문이 샐행 된다는 것을 알 수 있다.)

프로그램은 필요에 따라 쓰레드를 추가적으로 생성하는 것이 가능하며 이렇게 여러 쓰레드를 활용해서 프로그램을
제작하는 것을 멀티 쓰레드 프로그래밍이라고 한다. (+ 즉, 쓰레드를 활용하면 여러 작업을 동시에 처리하는 병렬 처리가
가능하다는 것을 의미한다.)

단, 오늘 날의 운영 체제는 특정 쓰레드가 CPU 의 작업 시간을 독점 할 수 없는 선점형 운영 체제이기 때문에
각 쓰레드마다 CPU 를 사용하는 시간이 다르며 어떤 쓰레드가 먼저 CPU 의 작업 시간을 할당 받을 지 알 수 없다.
(+ 즉, 멀티 쓰레드로 제작 된 프로그램은 실행 될 때 마다 쓰레드의 실행 순서가 다르다는 것을 알 수 있다.)

따라서 멀티 쓰레드 프로그래밍은 쓰레드의 작업 순서를 사용자 (프로그래머가) 가 제어해야하기 때문에
프로그램을 제작하는 난이도가 높다는 것을 알 수 있다. (+ 즉, 쓰레드마다 실행 시간이나 순서가 다르기 때문에
문제가 발생한 부분을 찾는 것이 어렵다는 것을 알 수 있다.)

멀티 쓰레드 프로그래밍을 할 때 발생하는 가장 대표적인 문제는 임계 영역 (Critical Section) 과
데드락 (Deadlock) 이다.

임계 영역 (Critical Section) 이란?
- 서로 다른 쓰레드가 같은 자원 (Ex. 변수) 에 동시에 접근해서 작업을 수행하는 현상을 의미한다.

선점형 운영 체제에서는 쓰레드가 CPU 작업 시간을 독점하는 것이 불가능하기 때문에 특정 쓰레드가
작업을 완료하기 전에 CPU 작업 시간이 다른 쓰레드에 넘어가면서 문제가 발생하며 이를 임계 영역이라고 한다.

따라서 서로 다른 쓰레드가 같은 자원에 접근 할 경우 특정 쓰레드가 작업을 완료하기 전에
다른 쓰레드에 CPU 작업 시간이 넘어가지 않도록 동기화 처리가 필수다. (+ 즉, 쓰레드가 작업을 완료하는 것을
보장하도록 명령문을 작성해야한다는 것을 알 수 있다.)

데드락 (Deadlock) 이란?
- 쓰레드가 특정 자원을 무한히 대기하는 현상을 의미한다. (+ 즉, 쓰레드가 자원을 무한히 기다림으로서
쓰레드가 먹통 된다는 것을 알 수 있다.)

쓰레드가 임계 영역 문제를 해결하기 위해서 주로 사용하는 동기화 처리 방식은 뮤텍스 (Mutex) 와 같은 고유 자원을
활용하는 방법이다.

뮤텍스는 고유 자원 중 하나로서 권한을 획득하는 방식으로 동작한다. (+ 즉, 뮤텍스 권한을 획득함으로서 특정 작업을
처리 할 수 있는 권한을 획득한다는 것을 알 수 있다.)

쓰레드는 뮤텍스의 권한을 획득하고 뮤텍스의 권한을 획득하지 못한 쓰레드는 권한을 획득 할 수 있을 때까지
대기함으로서 임계 영역 문제를 해결하는 것이 가능하다.

이때 뮤텍스의 권한을 획득한 쓰레드는 작업이 완료 되었을 경우 반드시 뮤텍스의 권한을 반납해야한다. (+ 즉,
획득한 뮤텍스의 권한 반납은 해당 뮤텍스를 사용하고 있는 쓰레드에서만 가능하다는 것을 알 수 있다.)

만약 뮤텍스의 권한을 반납하지 않을 경우 다른 쓰레드가 뮤텍스에 대한 권한을 획득하기 위해서 무한히 대기하는
데드락 현상이 발생한다. (+ 즉, 쓰레드가 동작을 멈춘다는 것을 의미한다.)

쓰레드를 사용하는 이유
- 비동기 작업
- CPU 성능 극대화

비동기 작업에 쓰레드를 사용하는 이유
- 비동기 작업에 쓰레드를 사용하는 사례 중 가장 대표적인 것은 블로킹 I/O (Blocking I/O) 작업을 할때이다.

크기가 작은 데이터는 빠른 속도로 I/O 가 이루어지기 때문에 별다른 문제가 되지 않지만 크기가 큰 데이터를
대상으로 I/O 작업을 할때는 I/O 작업이 완료 될 때까지 프로그램이 잠시 멈추는 문제가 발생한다. (+ 즉,
데이터를 I/O 하는 작업은 블로킹이기 때문에 작업이 완료 되기 전까지 프로그램의 흐름이 멈춰 있다는 것을
알 수 있다.)

따라서 이러한 현상은 사용자에게 큰 불편함을 주기 때문에 크기가 큰 데이터를 I/O 할때는 별도의 쓰레드를
사용해서 비동기로 처리 해줄 필요가 있다. (+ 즉, 서브 쓰레드가 I/O 로 인해 프로그램의 흐름이 멈춰 있다고
하더라도 메인 쓰레드는 영향을 받지 않는다는 것을 알 수 있다.)

CPU 성능 극대화에 쓰레드를 사용하는 이유
- 오늘 날의 CPU 는 코어를 여러 개 지니고 있는 멀티 코어 구조이기 때문에
CPU 의 성능을 최대한으로 이끌어내기 위해서는 코어를 적극적으로 활용 할 필요가 있다.

이때 쓰레드를 사용하면 멀티 코어를 활용하는 것이 가능하다.

쓰레드는 CPU 의 작업 시간을 할당 받는 기본 단위이며 1 개의 쓰레드는 1 개의 코어에서 처리가 된다. (+ 즉,
쓰레드가 여러 개라면 여러 코어에서 동시에 처리 된다는 것을 알 수 있다.)

따라서 여러 쓰레드를 활용하면 여러 작업을 병렬로 처리함으로서 CPU 의 성능을 최대한으로 이끌어내는 것이 가능하다.

Python 쓰레드 제약
- Python 의 쓰레드는 GIL (Global Interpreter Lock) 에 의해서 1 개의 쓰레드만 Python 명령문을
실행하도록 제한이 걸려있다. (+ 즉, 멀티 쓰레드를 활용해도 CPU 의 코어를 모두 사용하지 않고 1 개의 코어만을
사용한다는 것을 의미한다.)

따라서 일반적으로 Python 에서 쓰레드를 사용 할 때는 서로 간섭하지 않는 별개의 작업을 처리하거나
I/O 관련 작업을 처리 할 때 이다. (+ Ex. 파일 입/출력, 네트워크 입력 대기 등등...)

만약 Python 에서 GIL 문제를 우회해서 CPU 코어를 모두 활용하고 싶다면 쓰레드가 아닌 프로세스를 생성하면 된다.
(+ 즉, 프로세스를 여러 개 생성함으로서 GIL 문제를 해결하는 것이 가능하다.)

멀티 쓰레드 (Multi Thread) vs 멀티 프로세스 (Multi Process)
- 멀티 쓰레드는 프로세스 (실행 중인 프로그램) 내부에 존재하기 때문에 쓰레드 간에 데이터 교환이 간단하며
쓰레드 간에 흐름 전환 (Context Switching) 이 비교적 빠르다는 장점이 존재한다. (+ 즉, 쓰레드는
동일한 메모리 공간을 공유한다는 것을 알 수 있다.)

반면 멀티 프로세스는 프로세스마다 개별적인 메모리 공간을 사용하기 때문에 프로세스 간에 데이터 교환이 어렵고
프로세스 간에 흐름 전환이 느리다는 단점이 존재한다.

따라서 완전한 개별 작업이 아니라면 쓰레드를 사용하는 것이 일반적인 관례이다. (+ 즉, 멀티 쓰레드를 사용하는 것을
일반적으로 추천한다는 것을 알 수 있다.)
"""


# Example 17 (쓰레드)
def start(args):
	oCounter = CCounter()
	
	"""
	Thread 클래스란?
	- 쓰레드를 제어하기 위한 다양한 기능을 제공하는 클래스를 의미한다. (+ 즉, Thread 클래스를 활용하면
	쓰레드를 생성하고 제어하는 거싱 가능하다.)
	
	쓰레드는 흐름을 시작하기 위한 진입 함수가 필요하며 target 매개 변수에 지정해주면 된다. (+ 즉,
	Thread 클래스는 쓰레드를 생성하기 위한 다양한 데이터를 전달하는 것이 가능하다.)
	
	만약 진입 함수가 새로운 쓰레드에 의해 실행 되면서 해당 함수에 입력 데이터를 전달하고 싶다면
	args 매개 변수를 활용하면 된다. (+ 즉, args 매개 변수에 리스트 형식으로 입력 데이터를 전달하면
	해당 데이터는 진입 함수에 입력으로 전달 된다는 것을 알 수 있다.)
	"""
	oThreadA = threading.Thread(target = main_ThreadA, args = [oCounter])
	oThreadB = threading.Thread(target = main_ThreadB, args = [oCounter])
	
	"""
	daemon 속성이란?
	- 쓰레드의 데몬 여부를 설정하는 역할을 수행하는 속성을 의미한다. (+ 즉, daemon 속성을 활용하면
	쓰레드를 데몬 쓰레드로 설정하는 것이 가능하다.)
	
	데몬 쓰레드 (Daemon Thread) 란?
	- 메인 쓰레드가 종료되면 같이 종료되는 쓰레드를 의미한다. (+ 즉, 서브 쓰레드의 실행 완료 여부와 상관 없이
	메인 쓰레드가 종료되면 서브 쓰레드도 종료 된다는 것을 알 수 있다.)
	
	Python 의 쓰레드는 기본적으로 데몬 쓰레드가 아니기 때문에 메인 쓰레드가 종료 되더라도 서브 쓰레드는
	계속 실행되는 특징이 존재한다.
	
	따라서 메인 쓰레드가 종료 될 때 모든 쓰레드를 종료 시키고 싶다면 서브 쓰레드를 데몬 쓰레드로
	설정하면 된다.
	"""
	oThreadA.daemon = True
	oThreadB.daemon = True
	
	"""
	start 함수란?
	- 쓰레드를 시작하는 역할을 수행하는 함수를 의미한다. (+ 즉, start 메서드를 활용하면 쓰레드를
	동작시키는 것이 가능하다.)
	
	쓰레드는 처음 생성되면 실행 대기 상태이기 때문에 아무런 동작을 하지 않는다. (+ 즉, 필요한 시점에
	쓰레드를 동작 시킬 수 있다는 것을 의미한다.)
	
	따라서 start 함수를 호출하면 쓰레드가 실행 상태가 되며 CPU 작업 시간을 할당 받아 진입 함수에 존재하는
	명령문을 실행한다.
	"""
	oThreadA.start()
	oThreadB.start()
	
	"""
	join 함수란?
	- 쓰레드의 종료를 대기하는 역할을 수행하는 함수를 의미한다 (+ 즉, join 함수를 활용하면
	특정 쓰레드의 작업을 대기 후 이후 작업을 처리하는 것이 가능하다.)
	"""
	oThreadA.join()
	oThreadB.join()
	
	print(f"\n카운트 : {oCounter.m_nCount}")
	print("프로그램을 종료합니다.")
	

"""
Lock 클래스란?
- Python 에서 임계 영역 문제를 해결하기 위한 고유 자원 클래스를 의미한다. (+ 즉,
뮤텍스와 동일한 역할이라는 것을 알 수 있다.)
"""
# 동기화 객체
g_oLock = threading.Lock()

	
# 쓰레드 A 진입 함수
def main_ThreadA(a_oCounter):
	for i in range(0, 100000):
		"""
		acquire 함수란?
		- 동기화 객체로부터 고유 자원을 가져오는 함수를 의미한다. (+ 즉, 고유 자원을 가져올 수 없는
		상황이라면 자원을 가져올 수 있을때까지 프로그램의 흐름이 중단 된다는 것을 알 수 있다.)
		"""
		g_oLock.acquire()
		
		print("쓰레드 A 호출")
		a_oCounter.incrCount(1)
		
		"""
		release 함수란?
		- 고유 자원을 동기화 객체에게 반환하는 역할을 수행하는 함수를 의미한다. (+ 즉, 해당 함수를 통해
		고유 자원을 동기화 객체에게 반환하지 않으면 데드락 현상이 발생한다는 것을 알 수 있다.)
		"""
		g_oLock.release()


# 쓰레드 B 진입 함수
def main_ThreadB(a_oCounter):
	for i in range(0, 100000):
		"""
		아래와 같이 with 키워드를 활용하면 공유 자원을 안전하게 획득 및 반환하는 것이 가능하다. (+ 즉,
		with 블럭이 종료되면 자동으로 공유 자원을 동기화 객체에게 반환 된다는 것을 알 수 있다.)
		"""
		with g_oLock:
			print("쓰레드 B 호출")
			a_oCounter.incrCount(1)
		